{"ast":null,"code":"/*!\n * fresh\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\n * MIT Licensed\n */'use strict';/**\n * RegExp to check for no-cache token in Cache-Control.\n * @private\n */var CACHE_CONTROL_NO_CACHE_REGEXP=/(?:^|,)\\s*?no-cache\\s*?(?:,|$)/;/**\n * Module exports.\n * @public\n */module.exports=fresh;/**\n * Check freshness of the response using request and response headers.\n *\n * @param {Object} reqHeaders\n * @param {Object} resHeaders\n * @return {Boolean}\n * @public\n */function fresh(reqHeaders,resHeaders){// fields\nvar modifiedSince=reqHeaders['if-modified-since'];var noneMatch=reqHeaders['if-none-match'];// unconditional request\nif(!modifiedSince&&!noneMatch){return false;}// Always return stale when Cache-Control: no-cache\n// to support end-to-end reload requests\n// https://tools.ietf.org/html/rfc2616#section-14.9.4\nvar cacheControl=reqHeaders['cache-control'];if(cacheControl&&CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)){return false;}// if-none-match\nif(noneMatch&&noneMatch!=='*'){var etag=resHeaders['etag'];if(!etag){return false;}var etagStale=true;var matches=parseTokenList(noneMatch);for(var i=0;i<matches.length;i++){var match=matches[i];if(match===etag||match==='W/'+etag||'W/'+match===etag){etagStale=false;break;}}if(etagStale){return false;}}// if-modified-since\nif(modifiedSince){var lastModified=resHeaders['last-modified'];var modifiedStale=!lastModified||!(parseHttpDate(lastModified)<=parseHttpDate(modifiedSince));if(modifiedStale){return false;}}return true;}/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */function parseHttpDate(date){var timestamp=date&&Date.parse(date);// istanbul ignore next: guard against date.js Date.parse patching\nreturn typeof timestamp==='number'?timestamp:NaN;}/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */function parseTokenList(str){var end=0;var list=[];var start=0;// gather tokens\nfor(var i=0,len=str.length;i<len;i++){switch(str.charCodeAt(i)){case 0x20:/*   */if(start===end){start=end=i+1;}break;case 0x2c:/* , */list.push(str.substring(start,end));start=end=i+1;break;default:end=i+1;break;}}// final token\nlist.push(str.substring(start,end));return list;}","map":{"version":3,"names":["CACHE_CONTROL_NO_CACHE_REGEXP","module","exports","fresh","reqHeaders","resHeaders","modifiedSince","noneMatch","cacheControl","test","etag","etagStale","matches","parseTokenList","i","length","match","lastModified","modifiedStale","parseHttpDate","date","timestamp","Date","parse","NaN","str","end","list","start","len","charCodeAt","push","substring"],"sources":["C:/Users/Autor/Desktop/LaRuinaTV/api/src/node_modules/fresh/index.js"],"sourcesContent":["/*!\n * fresh\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to check for no-cache token in Cache-Control.\n * @private\n */\n\nvar CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = fresh\n\n/**\n * Check freshness of the response using request and response headers.\n *\n * @param {Object} reqHeaders\n * @param {Object} resHeaders\n * @return {Boolean}\n * @public\n */\n\nfunction fresh (reqHeaders, resHeaders) {\n  // fields\n  var modifiedSince = reqHeaders['if-modified-since']\n  var noneMatch = reqHeaders['if-none-match']\n\n  // unconditional request\n  if (!modifiedSince && !noneMatch) {\n    return false\n  }\n\n  // Always return stale when Cache-Control: no-cache\n  // to support end-to-end reload requests\n  // https://tools.ietf.org/html/rfc2616#section-14.9.4\n  var cacheControl = reqHeaders['cache-control']\n  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n    return false\n  }\n\n  // if-none-match\n  if (noneMatch && noneMatch !== '*') {\n    var etag = resHeaders['etag']\n\n    if (!etag) {\n      return false\n    }\n\n    var etagStale = true\n    var matches = parseTokenList(noneMatch)\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i]\n      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {\n        etagStale = false\n        break\n      }\n    }\n\n    if (etagStale) {\n      return false\n    }\n  }\n\n  // if-modified-since\n  if (modifiedSince) {\n    var lastModified = resHeaders['last-modified']\n    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))\n\n    if (modifiedStale) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  // istanbul ignore next: guard against date.js Date.parse patching\n  return typeof timestamp === 'number'\n    ? timestamp\n    : NaN\n}\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(str.substring(start, end))\n\n  return list\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}