{"ast":null,"code":"/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/var fs=require('fs');var path=require('path');function log(message/*: string */){console.log(\"[dotenv][DEBUG] \".concat(message));}var NEWLINE='\\n';var RE_INI_KEY_VAL=/^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/;var RE_NEWLINES=/\\\\n/g;var NEWLINES_MATCH=/\\n|\\r|\\r\\n/;// Parses src into an Object\nfunction parse(src/*: string | Buffer */,options/*: ?DotenvParseOptions */)/*: DotenvParseOutput */{var debug=Boolean(options&&options.debug);var obj={};// convert Buffers before splitting into lines and processing\nsrc.toString().split(NEWLINES_MATCH).forEach(function(line,idx){// matching \"KEY' and 'VAL' in 'KEY=VAL'\nvar keyValueArr=line.match(RE_INI_KEY_VAL);// matched?\nif(keyValueArr!=null){var key=keyValueArr[1];// default undefined or missing values to empty string\nvar val=keyValueArr[2]||'';var end=val.length-1;var isDoubleQuoted=val[0]==='\"'&&val[end]==='\"';var isSingleQuoted=val[0]===\"'\"&&val[end]===\"'\";// if single or double quoted, remove quotes\nif(isSingleQuoted||isDoubleQuoted){val=val.substring(1,end);// if double quoted, expand newlines\nif(isDoubleQuoted){val=val.replace(RE_NEWLINES,NEWLINE);}}else{// remove surrounding whitespace\nval=val.trim();}obj[key]=val;}else if(debug){log(\"did not match key and value when parsing line \".concat(idx+1,\": \").concat(line));}});return obj;}// Populates process.env from .env file\nfunction config(options/*: ?DotenvConfigOptions */)/*: DotenvConfigOutput */{var dotenvPath=path.resolve(process.cwd(),'.env');var encoding/*: string */='utf8';var debug=false;if(options){if(options.path!=null){dotenvPath=options.path;}if(options.encoding!=null){encoding=options.encoding;}if(options.debug!=null){debug=true;}}try{// specifying an encoding returns a string instead of a buffer\nvar parsed=parse(fs.readFileSync(dotenvPath,{encoding:encoding}),{debug:debug});Object.keys(parsed).forEach(function(key){if(!Object.prototype.hasOwnProperty.call(process.env,key)){process.env[key]=parsed[key];}else if(debug){log(\"\\\"\".concat(key,\"\\\" is already defined in `process.env` and will not be overwritten\"));}});return{parsed:parsed};}catch(e){return{error:e};}}module.exports.config=config;module.exports.parse=parse;","map":{"version":3,"names":["fs","require","path","log","message","console","NEWLINE","RE_INI_KEY_VAL","RE_NEWLINES","NEWLINES_MATCH","parse","src","options","debug","Boolean","obj","toString","split","forEach","line","idx","keyValueArr","match","key","val","end","length","isDoubleQuoted","isSingleQuoted","substring","replace","trim","config","dotenvPath","resolve","process","cwd","encoding","parsed","readFileSync","Object","keys","prototype","hasOwnProperty","call","env","e","error","module","exports"],"sources":["C:/Users/Autor/Desktop/LaRuinaTV/api/src/node_modules/dotenv/lib/main.js"],"sourcesContent":["/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}