{"ast":null,"code":"/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */'use strict';/**\n * Module dependencies.\n * @private\n */var typer=require('media-typer');var mime=require('mime-types');/**\n * Module exports.\n * @public\n */module.exports=typeofrequest;module.exports.is=typeis;module.exports.hasBody=hasbody;module.exports.normalize=normalize;module.exports.match=mimeMatch;/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */function typeis(value,types_){var i;var types=types_;// remove parameters and normalize\nvar val=tryNormalizeType(value);// no type or invalid\nif(!val){return false;}// support flattened arguments\nif(types&&!Array.isArray(types)){types=new Array(arguments.length-1);for(i=0;i<types.length;i++){types[i]=arguments[i+1];}}// no types, return the content type\nif(!types||!types.length){return val;}var type;for(i=0;i<types.length;i++){if(mimeMatch(normalize(type=types[i]),val)){return type[0]==='+'||type.indexOf('*')!==-1?val:type;}}// no matches\nreturn false;}/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */function hasbody(req){return req.headers['transfer-encoding']!==undefined||!isNaN(req.headers['content-length']);}/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */function typeofrequest(req,types_){var types=types_;// no body\nif(!hasbody(req)){return null;}// support flattened arguments\nif(arguments.length>2){types=new Array(arguments.length-1);for(var i=0;i<types.length;i++){types[i]=arguments[i+1];}}// request content type\nvar value=req.headers['content-type'];return typeis(value,types);}/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */function normalize(type){if(typeof type!=='string'){// invalid type\nreturn false;}switch(type){case'urlencoded':return'application/x-www-form-urlencoded';case'multipart':return'multipart/*';}if(type[0]==='+'){// \"+json\" -> \"*/*+json\" expando\nreturn'*/*'+type;}return type.indexOf('/')===-1?mime.lookup(type):type;}/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */function mimeMatch(expected,actual){// invalid type\nif(expected===false){return false;}// split types\nvar actualParts=actual.split('/');var expectedParts=expected.split('/');// invalid format\nif(actualParts.length!==2||expectedParts.length!==2){return false;}// validate type\nif(expectedParts[0]!=='*'&&expectedParts[0]!==actualParts[0]){return false;}// validate suffix wildcard\nif(expectedParts[1].substr(0,2)==='*+'){return expectedParts[1].length<=actualParts[1].length+1&&expectedParts[1].substr(1)===actualParts[1].substr(1-expectedParts[1].length);}// validate subtype\nif(expectedParts[1]!=='*'&&expectedParts[1]!==actualParts[1]){return false;}return true;}/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */function normalizeType(value){// parse the type\nvar type=typer.parse(value);// remove the parameters\ntype.parameters=undefined;// reformat it\nreturn typer.format(type);}/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */function tryNormalizeType(value){if(!value){return null;}try{return normalizeType(value);}catch(err){return null;}}","map":{"version":3,"names":["typer","require","mime","module","exports","typeofrequest","is","typeis","hasBody","hasbody","normalize","match","mimeMatch","value","types_","i","types","val","tryNormalizeType","Array","isArray","arguments","length","type","indexOf","req","headers","undefined","isNaN","lookup","expected","actual","actualParts","split","expectedParts","substr","normalizeType","parse","parameters","format","err"],"sources":["C:/Users/Autor/Desktop/LaRuinaTV/api/src/node_modules/type-is/index.js"],"sourcesContent":["/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar typer = require('media-typer')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = typeofrequest\nmodule.exports.is = typeis\nmodule.exports.hasBody = hasbody\nmodule.exports.normalize = normalize\nmodule.exports.match = mimeMatch\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction typeis (value, types_) {\n  var i\n  var types = types_\n\n  // remove parameters and normalize\n  var val = tryNormalizeType(value)\n\n  // no type or invalid\n  if (!val) {\n    return false\n  }\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1)\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // no types, return the content type\n  if (!types || !types.length) {\n    return val\n  }\n\n  var type\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1\n        ? val\n        : type\n    }\n  }\n\n  // no matches\n  return false\n}\n\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\nfunction hasbody (req) {\n  return req.headers['transfer-encoding'] !== undefined ||\n    !isNaN(req.headers['content-length'])\n}\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nfunction typeofrequest (req, types_) {\n  var types = types_\n\n  // no body\n  if (!hasbody(req)) {\n    return null\n  }\n\n  // support flattened arguments\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // request content type\n  var value = req.headers['content-type']\n\n  return typeis(value, types)\n}\n\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\nfunction normalize (type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded'\n    case 'multipart':\n      return 'multipart/*'\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type\n  }\n\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\nfunction mimeMatch (expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false\n  }\n\n  // split types\n  var actualParts = actual.split('/')\n  var expectedParts = expected.split('/')\n\n  // invalid format\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false\n  }\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false\n  }\n\n  // validate suffix wildcard\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 &&\n      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)\n  }\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction normalizeType (value) {\n  // parse the type\n  var type = typer.parse(value)\n\n  // remove the parameters\n  type.parameters = undefined\n\n  // reformat it\n  return typer.format(type)\n}\n\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction tryNormalizeType (value) {\n  if (!value) {\n    return null\n  }\n\n  try {\n    return normalizeType(value)\n  } catch (err) {\n    return null\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}